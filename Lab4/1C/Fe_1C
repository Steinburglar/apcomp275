import numpy, os
import matplotlib.pyplot as plt
from labutil.plugins.pwscf import run_qe_pwscf, PWscf_inparam
from labutil.objects import Struc, Dir, ase2struc, Kpoints, PseudoPotential, File
from ase.spacegroup import crystal
from ase.io import write
from ase.build import bulk


def parse_qe_pwscf_output(outfile):
    cell_parameters = None #for scf calculations when cell parameters are never reported, so it doesnt freak out
    with open(outfile.path, "r") as outf:
        for line in outf:
            if line.lower().startswith("     pwscf"):
                walltime = line.split()[-3] + line.split()[-2]
            if line.lower().startswith("     total force"):
                total_force = float(line.split()[3]) * (13.605698066 / 0.529177249)
            if line.lower().startswith("!    total energy"):
                total_energy = float(line.split()[-2]) * 13.605698066
            if line.lower().startswith("          total   stress"):
                pressure = float(line.split()[-1])
            if line.lower().startswith("cell_parameters"):
                # we could extract cell parameters here if needed
                cell_parameters = []
                for _ in range(3):
                    line = next(outf)
                    cell_parameters.append([float(x) for x in line.split()])
            if line.lower().startswith("     unit-cell volume"):
                volume = float(line.split()[-2])  # in Au^3
                volume = volume * 0.529177249**3  # convert to Angstrom^3
    result = {
        "energy": total_energy,
        "force": total_force,
        "pressure": pressure,
        "walltime": walltime,
        "cell_parameters": cell_parameters,
        "volume": volume,
    }
    return result



def make_struc(alat, form, clat = None, anti = False):
    """
    Creates the crystal structure using ASE.
    :param alat: Lattice parameter in angstrom
    :param form: Crystal form, e.g. 'bcc', 'hcp'
    :param clat: c lattice parameter for hcp
    :param anti: Boolean flag to include a fake Co in the structure, to allow for anti-ferromagnetic ordering
    :return: structure object converted from ase
    """
    fecell = bulk("Fe", form, a=alat, c=clat)
    # check how your cell looks like
    # write('s.cif', gecell)
    print(fecell, fecell.get_atomic_numbers())
    if anti:
        fecell.set_atomic_numbers([26, 27])
    structure = Struc(ase2struc(fecell))
    print(structure.species)
    return structure


def compute_energy(form, alat, nk, ecut, clat=None, anti=False, recalculate=False):
    """
    Make an input template and select potential and structure, and the path where to run
    """
    potname = "Fe.pbe-nd-rrkjus.UPF"
    potpath = os.path.join(os.environ["QE_POTENTIALS"], potname)
    pseudopots = {
        "Fe": PseudoPotential(
            path=potpath, ptype="uspp", element="Fe", functional="GGA", name=potname
        ),
        "Co": PseudoPotential(
            path=potpath, ptype="uspp", element="Fe", functional="GGA", name=potname
        ),
    }
    struc = make_struc(alat=alat, form=form, clat=clat, anti=anti)
    if form == "bcc":
        kpts = Kpoints(gridsize=[nk, nk, nk], option="automatic", offset=False)
    elif form == "hcp":
        kpts = Kpoints(gridsize=[nk, nk, int(nk/2)], option="automatic", offset=False)
    else:
        raise ValueError("Form not recognized")
    dirname = "Fe_{}_mag_{}".format(form, anti)
    runpath = Dir(path=os.path.join(os.environ["WORKDIR"], "Lab4/1C", dirname))

    # Check if calculation already exists and is complete
    if not recalculate and os.path.exists(runpath.path):
        existing_output = check_existing_calculation(runpath)
        if existing_output is not None:
            print(f"Found existing completed calculation in {runpath.path}")
            output = parse_qe_pwscf_output(outfile=existing_output)
            return output
        else:
            print(f"Existing calculation found but incomplete in {runpath.path}, rerunning...")
    #starting state is initialized as ferromagnetic unless anti is specified, or nonmag is specified
    input_params = PWscf_inparam(
        {
            "CONTROL": {
                "calculation": "vc-relax",
                "pseudo_dir": os.environ["QE_POTENTIALS"],
                "outdir": runpath.path,
                "tstress": True,
                "tprnfor": True,
                "disk_io": "none",
            },
            "SYSTEM": {
                "ecutwfc": ecut,
                "ecutrho": ecut * 10,
                "nspin": 2,
                "starting_magnetization(1)": 0.7,
                "occupations": "smearing",
                "smearing": "mp",
                "degauss": 0.02,
            },
            "ELECTRONS": {
                "diagonalization": "david",
                "mixing_beta": 0.5,
                "conv_thr": 1e-7,
            },
            "IONS": {},
            "CELL": {},
        }
    )

    ##untested, potential failure point
    if anti == "anti": 
        input_params["SYSTEM"]["starting_magnetization(1)"] = 1
        input_params["SYSTEM"]["starting_magnetization(2)"] = -1
    if anti == "nonmag":
        input_params["SYSTEM"]["nspin"] = 1
        input_params["SYSTEM"]["starting_magnetization(1)"] = 0
        input_params["SYSTEM"]["starting_magnetization(2)"] = 0
    output_file = run_qe_pwscf(
        runpath=runpath,
        struc=struc,
        pseudopots=pseudopots,
        params=input_params,
        kpoints=kpts,
        ncpu=2,
    )
    output = parse_qe_pwscf_output(outfile=output_file)
    return output

def check_existing_calculation(runpath):
    """
    Check if pwscf.out exists in the given directory.
    
    Parameters:
    runpath: Dir object with path to check
    
    Returns:
    File object pointing to pwscf.out if it exists, None otherwise
    """
    output_file_path = os.path.join(runpath.path, "pwscf.out")
    
    if os.path.exists(output_file_path):
        return File({"path": output_file_path})
    
    return None


def extract_lattice_parameters(cell_vectors, crystal_shape):
    """
    Extract lattice parameters from QE cell vectors (ASE primitive cells).
    
    Parameters:
    cell_vectors: list of 3 lists, each with 3 floats (the lattice vectors)
    crystal_shape: str, crystal structure type ('bcc', 'hcp')
    
    Returns:
    dict with relevant lattice parameters
    """
    import numpy as np
    
    a1, a2, a3 = [np.array(v) for v in cell_vectors]
    
    if crystal_shape.lower() == 'bcc':
        # BCC primitive: a1 = (a/2)*(-1,1,1), etc.
        # Lattice parameter: a = 2 * |a1[0]|
        alat = 2 * abs(a1[0])
        return {'a': alat}
        
    elif crystal_shape.lower() == 'hcp':
        # HCP: a1 = (a,0,0), a2 = (-a/2, a*sqrt(3)/2, 0), a3 = (0,0,c)
        # a-parameter: a = a1[0]
        # c-parameter: c = a3[2]  
        alat = a1[0]
        clat = a3[2]
        return {'a': alat, 'c': clat}
        

    else:
        raise ValueError(f"Crystal shape '{crystal_shape}' not implemented")


def lattice_scan(form, anti=False):
    #right now flexible onform of iron and number of kpoints
    nk = 14
    ecut = 30
    alat = 2.7 #halfway between expected bcc and hcp
    #clat = 4.2 #experimental c for hcp
    output = compute_energy(form, alat, nk, ecut, anti=anti)
    print(output)
    energy = output["energy"]
    return energy

if __name__ == "__main__":
    # put here the function that you actually want to run
    antis = ["ferro", "anti", "nonmag"]
    energies = {}
    for anti in antis:
        energy = lattice_scan("bcc", anti=anti)
        energies[anti] = energy
    #create a dataframe for the three cases
    import pandas as pd
    df = pd.DataFrame.from_dict(energies, orient='index', columns=['Energy (eV)'])
    print(df)